classdef Solver < handle
    properties
        inputReader_
        mesh_
        bcinit_
    end
    
    properties (Hidden)
        elements
        utils
        meshFileName
        soldofs
        loadVector
        freedofidxs
    end
    
    methods
        function obj = Solver(inputReader, mesh, bcinit)
                obj.inputReader_ = inputReader;
                obj.mesh_ = mesh;
                obj.bcinit_ = bcinit;
                obj.elements = Elements(); % Initialize Elements here
        
                % Get the number of nodes from the mesh
                numNodes = obj.mesh.getNumAllNodes();
        
                % Initialize the loadVector_ member with a size double the number of nodes
                obj.loadVector = obj.bcinit.getloadVector();
                obj.soldofs = zeros(1, 2 * numNodes);
                obj.soldofs(1:numel(obj.bcinit.getAllInitialDof())) = obj.bcinit.getAllInitialDof();
                obj.freedofidxs = obj.mesh.GetFreedofsIdx();
        
                % Initialize the thermoelectricityintegrationFunction_ using a function handle
                obj.thermoelectricityintegrationFunction = @(natcoords, coords, dofs, elementTag) obj.thermoelectricityintegration(natcoords, coords, dofs, elementTag);
        
                fprintf('### SOLVER Initialized.\n');
            end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function [KJ_b,R_b]=Assembly(obj)
            % FIXME:
                % define nnv and nele and improve their naming
            Ra=zeros(ndof,1);%KJa=sparse(ndof,ndof);
            KJvnz=zeros(nnv,nele);KJvc=zeros(nnv,nele);KJvr=zeros(nnv,nele);
            for  ii=1:nele
                % initialization to zeros for each element
                Rs=zeros(ndof,1);%KJs=sparse(ndof,ndof);

                % FIXME
                % modify the function to run with the gauss
                % previoously defined
                [KJ,R]=GaussKAS14A_TO(coord,order(ii,:),Te,Ve,matp,matv,ii,sysv,localval,xx(ii),p,seebp,rhop);

                % assembly in global residual and jacobian matrix in sparse format
                Rs(doforder,1)=R(:,1);      
                Ra=Ra+Rs;
                
                KJvnz(:,ii)=reshape(KJ,nnv,1);
                KJvc(:,ii)=reshape(repmat(doforder,20*2,1),nnv,1);
                KJvr(:,ii)=reshape(repmat(doforder,20*2,1)',nnv,1);

            end
            KJvnzr=reshape(KJvnz,nele*nnv,1);KJvcr=reshape(KJvc,nele*nnv,1);KJvrr=reshape(KJvr,nele*nnv,1); % is this needed??
            KJs=sparse(KJvrr,KJvcr,KJvnzr,ndof,ndof);
            R_b=Ra(freedofs)-F(freedofs)+K_conv(freedofs,freedofs)*U(freedofs);
            KJ_b=KJs(freedofs,freedofs)-K_conv(freedofs,freedofs);
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function result = gaussIntegrationK(dimension, order, elementTag, mesh, bcvalue, func)
            if dimension < 1 || order < 1
                fprintf('Invalid dimension or order for Gauss integration.\n');
                result = zeros(1, 1); % Initialize result to a 1x1 matrix with zero value.
                return;
            end
           
            [weights, gaussPoints] = getGaussWeightsAndPoints(order);
            
            if isempty(weights) || isempty(gaussPoints)
                fprintf('Invalid order for Gauss integration.\n');
                result = zeros(1, 1); % Initialize result to a 1x1 matrix with zero value.
                return;
            end
            
            if size(weights, 1) ~= size(gaussPoints, 1)
                fprintf('Weights and Gauss points have mismatched dimensions.\n');
                result = zeros(1, 1); % Initialize result to a 1x1 matrix with zero value.
                return;
            end
            
            if dimension == 1
                % 1D integration using a single loop.
                natcoords = zeros(1, 1);
                for i = 1:size(weights, 1)
                    natcoords(1) = gaussPoints(i);
                    % Explicitly use the element-wise multiplication .* for arrays
                    f = func(natcoords, coordinates_tr_XY, bcvalue, elementTag, mesh) .* weights(i);
                    result = result + f;
                end
            elseif dimension == 2
                % 2D integration using a double loop.
                natcoords = zeros(2, 1);
                for i = 1:size(weights, 1)
                    for j = 1:size(weights, 1)
                        natcoords(1) = gaussPoints(i);
                        natcoords(2) = gaussPoints(j);
                        % Explicitly use the element-wise multiplication .* for arrays
                        f = func(natcoords, coordinates_tr_XY, bcvalue, elementTag, mesh) .* (weights(i) * weights(j));
                        result = result + f;
                    end
                end
            elseif dimension == 3
                if order == 14
                    % Special case for 3D integration with order 14.
                    result = weights * weights' .* weights * weights' .* weights * weights' .* func(gaussPoints, coordinates_tr_XY, bcvalue, elementTag, mesh);
                else
                    % Generic 3D integration using a triple loop.
                    natcoords = zeros(3, 1);
                    for i = 1:size(weights, 1)
                        for j = 1:size(weights, 1)
                            for k = 1:size(weights, 1)
                                natcoords(1) = gaussPoints(i);
                                natcoords(2) = gaussPoints(j);
                                natcoords(3) = gaussPoints(k);
                                % Explicitly use the element-wise multiplication .* for arrays
                                f = func(natcoords, coordinates_tr_XY, bcvalue, elementTag, mesh) .* (weights(i) * weights(j) * weights(k));
                                result = result + f;
                            end
                        end
                    end
                end
            else
                fprintf('Invalid dimension for Gauss integration.\n');
                result = zeros(1, 1); % Initialize result to a 1x1 matrix with zero value.
            end
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function [KJ, R] = thermoelectricityintegrationFunction(obj,elementTag,mesh,xi,eta,zeta,etype)
            %% Thermoelectricity Simulation
            % This function calculates thermoelectric properties using finite element analysis.
            % Inputs:
            %
            % Outputs:
            %   - KJ: Jacobian matrix
            %   - R: Residues
            
            % Extract coordinates for the current order
            element_nodes = mesh.data.ELEMENTS{elementTag};
            element_coordinates=zeros(3,length(element_nodes));
            Tee=zeros(1,element_nodes);
            Vee=zeros(1,element_nodes);
            for i = 1: length(element_nodes)
                element_coordinates(:,i)=mesh.data.NODE{element_nodes(i)};
                Tee(i)=dofs(element_nodes*2);
                Vee(i)=dofs(element_nodes*2+1);
            end
            element_material_index=
            
           
                % FIXME: Calculate shape functions
                [N, dShape] = mesh.selectShapeFunctionsAndDerivatives(etype, xi, eta, zeta);

                JM = dShape * element_coordinates;
                %Jacinv = inv(JM);
                DN = Jacinv \ dShape; % FIXME and check it is the same!
            
                % FIXME, calculate from all dofs input
                Th = N' * Tee;
            
                % FIXME: Calculate material properties
                De = 
                Dde=0;Dda=0;Ddk=0;
            
                detJ = det(JM);
            
                % Calculate current density and heat flux
                je = -De * DN * Vee - Da * De * DN * Tee;
                qe = Da * (N' * Tee) * je - Dk * DN * Tee;
            
                % Calculate derivatives
                djdt = -Da * De * DN - Dda * De * DN * Tee * N' - Dde * (DN * Ve + Da * DN * Tee) * N';
                djdv = -De * DN;
                dqdt = Da * Th * djdt + Da * je * N' - Dk * DN + Dda * Th * je * N' - Ddk * DN * Tee * N';
                dqdv = -Da * De * Th * DN;
            
                % Update residues
                RT = detJ*(-(DN' * qe) + (N * je') * (DN * Vee));
                RV = detJ*(-DN' * je);
            
                % Update stiffness matrices
                K11 = detJ*(DN' * dqdt - N * (djdt' * DN * Vee)');
                K12 = detJ*(DN' * dqdv - N * (djdv' * DN * Vee)' - N * (je' * DN));
                K21 = detJ*(DN' * djdt);
                K22 = detJ*(DN' * djdv);
            
                % Construct the elemental Jacobian matrix and Residues
                KJ = [K11, K12; K21, K22];
                R = [RT(:, 1); RV(:, 1)];
            
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function solveSparseSystem(obj, KsubMatrix, R_reduced, solution)
            % Implement your code here
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function result = runNewtonRaphson(obj)
            % Implement your code here
        end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        function solDofs = getAllSolDofs(obj)
            solDofs = obj.soldofs;
        end
        
        function solDof = getAllSolDof(obj, i)
            solDof = obj.soldofs(i);
        end
        
        function result = runArcLengthSolver(obj)
            % Implement your code here
        end
        
        function result = runModifiedNewtonRaphsonSolver(obj, applyLoadIncrements)
            % Implement your code here
        end
        
        function result = runNewtonRaphsonWithUniformIncrements(obj, totalLoadVector, numUniformIncrements)
            % Implement your code here
        end
    end
    
    methods (Access = private)
        function result = thermoelectricityintegration(obj, natcoords, coords, dofs, elementTag)
            % Implement your code here
        end
    end
end
